//
//  BluetoothManager.swift
//  Freespeed
//
//  Created by Richard Melik on 19/12/2025.
//

import Foundation
import CoreBluetooth
import Combine

enum BluetoothStateDisplay: String {
    case unknown = "Unknown"
    case resetting = "Resetting"
    case unsupported = "Unsupported"
    case unauthorized = "Unauthorized"
    case poweredOff = "Powered Off"
    case poweredOn = "Powered On"
}

enum DeviceCategory: String, Codable {
    case trainer = "Trainer"
    case powerMeter = "Power Meter"
    case heartRate = "Heart Rate"
    case cadence = "Cadence"
}

struct DiscoveredDevice: Identifiable, Equatable, Hashable {
    let peripheral: CBPeripheral
    let category: DeviceCategory
    var customName: String?
    var isConnected: Bool = false
    
    var id: UUID { peripheral.identifier }
    
    var defaultName: String {
        peripheral.name ?? "Unknown device"
    }
    
    var displayName: String {
        customName ?? defaultName
    }
    
    static func == (lhs: DiscoveredDevice, rhs: DiscoveredDevice) -> Bool {
        lhs.id == rhs.id
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}

class BluetoothManager: NSObject, ObservableObject {
    @Published var state: BluetoothStateDisplay = .unknown
    @Published var devices: [DiscoveredDevice] = []
    
    private var central: CBCentralManager!
    private let metrics: WorkoutMetrics
    
    // Service UUIDs we care about
    private let heartRateServiceUUID = CBUUID(string: "180D")
    private let cscServiceUUID = CBUUID(string: "1816")
    private let cyclingPowerServiceUUID = CBUUID(string: "1818")
    private let ftmsServiceUUID = CBUUID(string: "1826")
    
    // Characteristic UUIDs
    private let heartRateMeasurementUUID = CBUUID(string: "2A37")
    private let cscMeasurementUUID = CBUUID(string: "2A5B")
    private let cyclingPowerMeasurementUUID = CBUUID(string: "2A63")
    private let indoorBikeDataUUID = CBUUID(string: "2AD2")  // FTMS Indoor Bike Data
    private let ftmsControlPointUUID = CBUUID(string: "2AD9") // FTMS Fitness Machine Control Point
    
    private let labelsKey = "BLEDeviceLabels"
    private var savedLabels: [String: String] = [:]
    
    // For cadence from crank data (per device)
    private var lastCrankData: [UUID: (revs: UInt16, eventTime: UInt16)] = [:]
    
    // For "no data" reset to 0
    private var lastHeartRateUpdate: Date?
    private var lastCadenceUpdate: Date?
    private var lastSpeedUpdate: Date?
    private var staleDataTimer: Timer?
    
    // Track which devices are used as power sources
    private var primaryPowerDeviceID: UUID?
    private var secondaryPowerDeviceID: UUID?
    
    // FTMS control point
    private var ftmsControlPointCharacteristics: [UUID: CBCharacteristic] = [:]
    private var ftmsRequestedControl: Set<UUID> = []
    
    init(metrics: WorkoutMetrics) {
        self.metrics = metrics
        super.init()
        loadLabels()
        central = CBCentralManager(delegate: self, queue: .main)
        
        // Timer to clear stale HR/cadence/speed
        staleDataTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.checkForStaleMetrics()
        }
    }
    
    // MARK: - Public API
    
    func startScanning() {
        guard central.state == .poweredOn else { return }
        
        let services = [
            heartRateServiceUUID,
            cscServiceUUID,
            cyclingPowerServiceUUID,
            ftmsServiceUUID
        ]
        
        central.scanForPeripherals(withServices: services,
                                   options: [CBCentralManagerScanOptionAllowDuplicatesKey: false])
    }
    
    func stopScanning() {
        central.stopScan()
    }
    
    func connect(_ device: DiscoveredDevice) {
        central.connect(device.peripheral, options: nil)
    }
    
    func disconnect(_ device: DiscoveredDevice) {
        central.cancelPeripheralConnection(device.peripheral)
    }
    
    func updateCustomName(for deviceID: UUID, to newName: String?) {
        let key = deviceID.uuidString
        
        if let newName, !newName.isEmpty {
            savedLabels[key] = newName
        } else {
            savedLabels.removeValue(forKey: key)
        }
        
        UserDefaults.standard.set(savedLabels, forKey: labelsKey)
        
        if let index = devices.firstIndex(where: { $0.id == deviceID }) {
            devices[index].customName = newName
        }
    }
    
    /// Simple ERG control: set FTMS target power (watts) on the first connected trainer
    func setErgTargetPower(_ watts: Int) {
        // Find first connected FTMS trainer
        guard let trainerDevice = devices.first(where: { $0.category == .trainer && $0.isConnected }) else {
            print("No connected FTMS trainer for ERG")
            return
        }
        guard let peripheral = trainerDevice.peripheral as CBPeripheral? else { return }
        
        guard let controlPoint = ftmsControlPointCharacteristics[peripheral.identifier] else {
            print("No FTMS control point characteristic discovered for trainer")
            return
        }
        
        ensureFTMSControl(for: peripheral, controlPoint: controlPoint)
        
        // FTMS Set Target Power opcode = 0x05, parameter = int16 watts (little endian)
        let clampedWatts = max(-32768, min(32767, watts))
        let w = UInt16(bitPattern: Int16(clampedWatts))
        
        let value: [UInt8] = [
            0x05,
            UInt8(w & 0xFF),
            UInt8((w >> 8) & 0xFF)
        ]
        
        let data = Data(value)
        peripheral.writeValue(data, for: controlPoint, type: .withResponse)
        
        DispatchQueue.main.async {
            self.metrics.ergTargetWatts = watts
        }
    }
    
    // MARK: - Persistence
    
    private func loadLabels() {
        if let dict = UserDefaults.standard.dictionary(forKey: labelsKey) as? [String: String] {
            savedLabels = dict
        }
    }
    
    private func labelFor(_ peripheral: CBPeripheral) -> String? {
        savedLabels[peripheral.identifier.uuidString]
    }
    
    // MARK: - Stale data handling
    
    private func checkForStaleMetrics() {
        let now = Date()
        let timeout: TimeInterval = 5.0
        
        if let last = lastHeartRateUpdate, now.timeIntervalSince(last) > timeout {
            metrics.heartRate = 0
            lastHeartRateUpdate = nil
        }
        
        if let last = lastCadenceUpdate, now.timeIntervalSince(last) > timeout {
            metrics.cadence = 0
            lastCadenceUpdate = nil
        }
        
        if let last = lastSpeedUpdate, now.timeIntervalSince(last) > timeout {
            metrics.speedKmh = 0
            lastSpeedUpdate = nil
        }
    }
    
    // MARK: - Helper: power source management
    
    private func displayName(for peripheral: CBPeripheral) -> String {
        if let device = devices.first(where: { $0.id == peripheral.identifier }) {
            return device.displayName
        }
        return peripheral.name ?? "Unknown device"
    }
    
    private func updatePower(for peripheral: CBPeripheral, watts: Int) {
        let id = peripheral.identifier
        
        if primaryPowerDeviceID == nil {
            primaryPowerDeviceID = id
        }
        
        if primaryPowerDeviceID == id {
            metrics.primaryPowerInstant = watts
            metrics.primaryPowerSourceName = displayName(for: peripheral)
        } else if secondaryPowerDeviceID == nil {
            secondaryPowerDeviceID = id
            metrics.secondaryPowerInstant = watts
            metrics.secondaryPowerSourceName = displayName(for: peripheral)
        } else if secondaryPowerDeviceID == id {
            metrics.secondaryPowerInstant = watts
            metrics.secondaryPowerSourceName = displayName(for: peripheral)
        } else {
            // More than two power-capable devices: ignore extra ones for now
        }
    }
    
    // MARK: - FTMS control helpers
    
    private func ensureFTMSControl(for peripheral: CBPeripheral, controlPoint: CBCharacteristic) {
        let id = peripheral.identifier
        guard !ftmsRequestedControl.contains(id) else { return }
        ftmsRequestedControl.insert(id)
        
        // Request Control opcode = 0x00
        let data = Data([0x00])
        peripheral.writeValue(data, for: controlPoint, type: .withResponse)
    }
}

// MARK: - CBCentralManagerDelegate

extension BluetoothManager: CBCentralManagerDelegate {
    func centralManagerDidUpdateState(_ central: CBCentralManager) {
        switch central.state {
        case .unknown:
            state = .unknown
        case .resetting:
            state = .resetting
        case .unsupported:
            state = .unsupported
        case .unauthorized:
            state = .unauthorized
        case .poweredOff:
            state = .poweredOff
        case .poweredOn:
            state = .poweredOn
            startScanning()
        @unknown default:
            state = .unknown
        }
    }
    
    func centralManager(_ central: CBCentralManager,
                        didDiscover peripheral: CBPeripheral,
                        advertisementData: [String : Any],
                        rssi RSSI: NSNumber) {
        
        guard let category = inferCategory(from: advertisementData) else { return }
        
        if let index = devices.firstIndex(where: { $0.id == peripheral.identifier }) {
            devices[index] = DiscoveredDevice(
                peripheral: peripheral,
                category: category,
                customName: devices[index].customName,
                isConnected: devices[index].isConnected
            )
            return
        }
        
        let device = DiscoveredDevice(
            peripheral: peripheral,
            category: category,
            customName: labelFor(peripheral),
            isConnected: false
        )
        
        devices.append(device)
    }
    
    func centralManager(_ central: CBCentralManager,
                        didConnect peripheral: CBPeripheral) {
        peripheral.delegate = self
        
        if let index = devices.firstIndex(where: { $0.id == peripheral.identifier }) {
            devices[index].isConnected = true
        }
        
        peripheral.discoverServices(nil)
    }
    
    func centralManager(_ central: CBCentralManager,
                        didDisconnectPeripheral peripheral: CBPeripheral,
                        error: Error?) {
        if let index = devices.firstIndex(where: { $0.id == peripheral.identifier }) {
            devices[index].isConnected = false
        }
    }
}

// MARK: - CBPeripheralDelegate

extension BluetoothManager: CBPeripheralDelegate {
    func peripheral(_ peripheral: CBPeripheral,
                    didDiscoverServices error: Error?) {
        guard error == nil else {
            print("Service discovery error: \(error!)")
            return
        }
        
        guard let services = peripheral.services else { return }
        
        for service in services {
            switch service.uuid {
            case heartRateServiceUUID:
                peripheral.discoverCharacteristics([heartRateMeasurementUUID], for: service)
            case cyclingPowerServiceUUID:
                peripheral.discoverCharacteristics([cyclingPowerMeasurementUUID], for: service)
            case cscServiceUUID:
                peripheral.discoverCharacteristics([cscMeasurementUUID], for: service)
            case ftmsServiceUUID:
                // FTMS – Indoor Bike Data + Control Point
                peripheral.discoverCharacteristics([indoorBikeDataUUID, ftmsControlPointUUID], for: service)
            default:
                break
            }
        }
    }
    
    func peripheral(_ peripheral: CBPeripheral,
                    didDiscoverCharacteristicsFor service: CBService,
                    error: Error?) {
        guard error == nil else {
            print("Characteristic discovery error: \(error!)")
            return
        }
        
        guard let characteristics = service.characteristics else { return }
        
        for characteristic in characteristics {
            // Enable notifications/indications where appropriate
            if characteristic.properties.contains(.notify) ||
                characteristic.properties.contains(.indicate) {
                peripheral.setNotifyValue(true, for: characteristic)
            }
            
            // Cache FTMS control point
            if characteristic.uuid == ftmsControlPointUUID {
                ftmsControlPointCharacteristics[peripheral.identifier] = characteristic
            }
        }
    }
    
    func peripheral(_ peripheral: CBPeripheral,
                    didUpdateValueFor characteristic: CBCharacteristic,
                    error: Error?) {
        guard error == nil, let data = characteristic.value else { return }
        
        switch characteristic.uuid {
        case heartRateMeasurementUUID:
            handleHeartRate(data)
        case cyclingPowerMeasurementUUID:
            handleCyclingPower(peripheral: peripheral, data: data)
        case cscMeasurementUUID:
            handleCSC(peripheral: peripheral, data: data)
        case indoorBikeDataUUID:
            handleFTMSIndoorBikeData(peripheral: peripheral, data: data)
        case ftmsControlPointUUID:
            // Control point response (we’ll just log for now)
            print("FTMS Control Point response: \(data as NSData)")
        default:
            break
        }
    }
}

// MARK: - Parsing & category helpers

extension BluetoothManager {
    private func inferCategory(from advertisementData: [String: Any]) -> DeviceCategory? {
        guard let serviceUUIDs = advertisementData[CBAdvertisementDataServiceUUIDsKey] as? [CBUUID],
              !serviceUUIDs.isEmpty else {
            return nil
        }
        
        if serviceUUIDs.contains(ftmsServiceUUID) {
            return .trainer
        }
        if serviceUUIDs.contains(cyclingPowerServiceUUID) {
            return .powerMeter
        }
        if serviceUUIDs.contains(cscServiceUUID) {
            return .cadence
        }
        if serviceUUIDs.contains(heartRateServiceUUID) {
            return .heartRate
        }
        
        return nil
    }
    
    private func handleHeartRate(_ data: Data) {
        guard data.count >= 2 else { return }
        let flags = data[0]
        let isUInt16 = (flags & 0x01) != 0
        
        let hr: Int
        if isUInt16 {
            guard data.count >= 3 else { return }
            hr = Int(UInt16(data[1]) | (UInt16(data[2]) << 8))
        } else {
            hr = Int(data[1])
        }
        
        DispatchQueue.main.async {
            self.metrics.heartRate = hr
            self.lastHeartRateUpdate = Date()
        }
    }
    
    // CPS – power only (cadence from CSC/FTMS instead)
    private func handleCyclingPower(peripheral: CBPeripheral, data: Data) {
        let bytes = [UInt8](data)
        guard bytes.count >= 4 else { return }
        
        // Instantaneous Power (signed 16-bit, W)
        let powerValue = Int16(bitPattern: UInt16(bytes[2]) | (UInt16(bytes[3]) << 8))
        let watts = Int(powerValue)
        
        DispatchQueue.main.async {
            self.updatePower(for: peripheral, watts: watts)
        }
    }
    
    // FTMS Indoor Bike Data (0x2AD2)
    private func handleFTMSIndoorBikeData(peripheral: CBPeripheral, data: Data) {
        let bytes = [UInt8](data)
        guard bytes.count >= 4 else { return }
        
        // Flags: 16-bit little endian
        let flags = UInt16(bytes[0]) | (UInt16(bytes[1]) << 8)
        var index = 2
        
        var instantaneousSpeedKmh: Double?
        var instantaneousCadenceRPM: Int?
        var instantaneousPowerWatts: Int?
        
        // Instantaneous Speed (uint16, 0.01 km/h)
        guard bytes.count >= index + 2 else { return }
        let rawSpeed = UInt16(bytes[index]) | (UInt16(bytes[index + 1]) << 8)
        instantaneousSpeedKmh = Double(rawSpeed) / 100.0
        index += 2
        
        // Average Speed present? (bit 1)
        if (flags & (1 << 1)) != 0 {
            guard bytes.count >= index + 2 else { return }
            index += 2
        }
        
        // Instantaneous Cadence present? (bit 2) – uint16, 0.5 rev/min
        if (flags & (1 << 2)) != 0 {
            guard bytes.count >= index + 2 else { return }
            let rawCadence = UInt16(bytes[index]) | (UInt16(bytes[index + 1]) << 8)
            instantaneousCadenceRPM = Int(round(Double(rawCadence) / 2.0))
            index += 2
        }
        
        // Average Cadence present? (bit 3)
        if (flags & (1 << 3)) != 0 {
            guard bytes.count >= index + 2 else { return }
            index += 2
        }
        
        // Total Distance present? (bit 4) – uint24
        if (flags & (1 << 4)) != 0 {
            guard bytes.count >= index + 3 else { return }
            index += 3
        }
        
        // Resistance Level present? (bit 5) – int16
        if (flags & (1 << 5)) != 0 {
            guard bytes.count >= index + 2 else { return }
            index += 2
        }
        
        // Instantaneous Power present? (bit 6) – int16, W
        if (flags & (1 << 6)) != 0 {
            guard bytes.count >= index + 2 else { return }
            let rawPower = Int16(bitPattern: UInt16(bytes[index]) | (UInt16(bytes[index + 1]) << 8))
            instantaneousPowerWatts = Int(rawPower)
            index += 2
        }
        
        DispatchQueue.main.async {
            if let watts = instantaneousPowerWatts {
                self.updatePower(for: peripheral, watts: watts)
            }
            
            if let speed = instantaneousSpeedKmh {
                self.metrics.speedKmh = speed
                self.lastSpeedUpdate = Date()
            }
            
            if let cadence = instantaneousCadenceRPM,
               cadence >= 20, cadence <= 200 {
                self.metrics.cadence = cadence
                self.lastCadenceUpdate = Date()
            }
        }
    }
    
    // Cadence from CSC (Cycling Speed & Cadence) Measurement (0x2A5B)
    private func handleCSC(peripheral: CBPeripheral, data: Data) {
        let bytes = [UInt8](data)
        guard !bytes.isEmpty else { return }
        
        let flags = bytes[0]
        let wheelDataPresent = (flags & 0x01) != 0
        let crankDataPresent = (flags & 0x02) != 0
        
        var index = 1
        
        // Skip wheel data (4 bytes revs + 2 bytes time) if present
        if wheelDataPresent {
            guard bytes.count >= index + 6 else { return }
            index += 6
        }
        
        // Need crank data for cadence
        guard crankDataPresent else { return }
        guard bytes.count >= index + 4 else { return }
        
        let revs = UInt16(bytes[index]) | (UInt16(bytes[index + 1]) << 8)
        let eventTime = UInt16(bytes[index + 2]) | (UInt16(bytes[index + 3]) << 8)
        
        let deviceID = peripheral.identifier
        
        if let last = lastCrankData[deviceID] {
            let deltaRevs = UInt16(revs &- last.revs)
            let deltaTimeTicks = UInt16(eventTime &- last.eventTime)
            
            if deltaTimeTicks > 0 {
                let seconds = Double(deltaTimeTicks) / 1024.0
                let cadenceRPM = Int(round((Double(deltaRevs) / seconds) * 60.0))
                
                if cadenceRPM >= 20 && cadenceRPM <= 200 {
                    DispatchQueue.main.async {
                        self.metrics.cadence = cadenceRPM
                        self.lastCadenceUpdate = Date()
                    }
                }
            }
        }
        
        // store latest data
        lastCrankData[deviceID] = (revs: revs, eventTime: eventTime)
    }
}
